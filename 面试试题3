@20190826
##常用的集合类有哪些 ？具有哪些特性？是否有序，是否可以为null？是否排序？是否重复？
###实现list接口的类   有序、可重复
Linklist 实现List接口 ，允许null 。提供了额外的 get remove insert  LinkList没有同步方法，多线程访问时必须自己实现同步访问
ArrayList 实现可变大小的数组，允许所有元素 包括null ；没有同步 
Vector类似ArrayList，但是Vector是同步的。
Stack继承自vector，实现一个后进先出的堆栈。Stack提供五个额外的方法 push() 向尾端插入一个；pop 尾端删除 ；peek（）得到栈顶元素 
empty（）测试堆栈是否为空 search（）查找一个元素在堆栈中的位置。
    
###实现set接口的类 
无序、不能重复  最多只能有一个null
treeset ：二叉排序树 有序 

Map（键值对、键唯一、值不唯一）

数组 读写快 ；链表 增删快；哈希表 散列结构。
##collections array 工具类；
Collection 集合处理的工具类<br/>
排序  反转 随机排序 按自然顺序的升序排序，定制排序 交换索引位置的参数，
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。
当distance为负数时，将 list的前distance个元素整体移到后面。
查找binarySearch(List list, Object key) 二分查找返回索引，Max（）返回最大值的元素  替换 
同步控制 效率低 
Arrays类的常见操作<br/>
数组进行处理的工具类
排序 : sort() 
查找 : binarySearch() 
比较: equals() 
填充 : fill() 
转列表: asList() 
转字符串 : toString()  
##Comparator 和 Comparable 接口的作用和异同点？  <br/>
用来对自定义的class比较大小，<br/>
Comparable定义在类的内部，实现Comparable接口要覆盖compareTo方法, 在compareTo方法里面实现比较：<br/>

Comparator定义在person的外部，实现Comparator需要覆盖 compare 方法：<br/>

##泛型，什么是泛型，泛型的好处？
使用泛型时，类型转换由编译器完成，如果不使用泛型，类型转换由编程人员自己显式处理；<br/>
使用泛型，可以避免大量的方法的重载；<br/>
在编程时，如果指明了具体的泛型类型，则所用到的数据类型必须与泛型类型一致，即使可以进行类型自动转换也不允许；<br/>
在使用泛型时，指明的泛型的具体类型只能是引用类型，不能是基本类型，基本类型应该使用其对应的包装类类型；<br/>

泛型和方法重载有什么联系，泛型可以不可以使用基本类型，只能用包装类
是程序在编程时为了达到代码复用，在类、方法声明定义时，而使用泛型符号用于指代某种类型的一种编程方式；



##HashMap的底层实现的数据结构？  1.7- 数据+链表  1.8 数组+链表+红黑树 
HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改
可以接受null和键值; 基于hashing的原理，我们使用put（key，value）存储对象到hashMap中，
使用get（key）从Hashmap中获取对象。当我们给put方法传递键值时，先对键调用hashCode方法计算并
返回的hashCode是用于找到Map数组的bucket位置来储存Node对象。HashMap在bucjet中储存键对象和值对象，最为Map。Node


## 什么是红黑树 ？ 在hashMap中链表是如何转换为红黑树的，为什么使用红黑树。
自平衡二叉查找树 ，根节点是黑色的，叶子节点是黑色的空结点，红色节点的字节点是黑色的。
当链表长度超过8时，通过treeifyBin()方法转化成红黑树，
判断是否由根节点，然后选择插入左子树还是右子树 。

红黑树的插入删除和遍历的最坏时间复杂度都是log（n），当出现意外或恶意使用下导致hashCode（）方法返回值很差时，
性能下降少；

##HashMap的负载银子 是 0.75. Hash是如何扩容的？按照 16的整数倍递增。 Hash的初始长度为多少？ 16 
Map<String,object> map=new hashMap(30);

##什么叫对象流 是将内存中的某个时间节点的状体信息以字节流的形式，持久化到硬盘

什么是序列化 ？什么是反序列化？Serarizable接口的作用
把对象转换为字节序列的过程称为对象的序列化。
注意是对象
反序列化：把字节序列恢复为对象的过程称为对象的反序列化。

通过该接口启动序列化功能
未实现此接口的类将无法使其任何状态序列化或反序列化。
可序列化类的所有子类型本身都是可序列化的。因为实现接口也是间接的等同于继承。
序列化接口没有方法或字段，仅用于标识可序列化的语义。


##Transient关键字作用？修饰对象属性，不会被序列化，是否可以和final，static搭配使用？以及他们之间的区别 
用transient关键字标记的成员变量不参与序列化过程。
static 也无法被序列化 ，Transient修饰的变量在涉及序列化之外的地方就是正常的变量

##编程题 输入一个文件目录，将该文件目录中的文件内容汇总中含有java文件关键字的文件进行输出 递归 FileFilter接口


##扩展 NIO和NIO2的编程方式 

##什么是进程？什么是线程 ？进程与线程之间的异同点？
程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
 线程是进程的执行的最小单位 单个进程中执行每个任务就是一个线程。
##线程的状态以及转换方式 ？
    就绪 运行 堵塞 
 挂起就绪 就绪 运行 堵塞（等待） 挂起等待    
新建 就绪 运行 堵塞  退出
##java多线程编程的实现方法？常用的线程操作的方法？

##多线程可以直接调用run方法，执行线程吗？
##线程类实现后，调用run方法和start方法有什么区别 ？  
调用run方法只是调用了一个run方法，但是线程机制并没有启动。
##多线程常用的方法

线程死锁？线程死锁产生的条件 ？
互斥 请求与保持 循环等待 不可剥夺
如何避免线程产生死锁？Synchronize关键字的用法？

##什么是线程同步？

##线程的通信机制，
扩展 
##ConcurrentHashMap如何实现多线程并发的？ CAS无锁化解决多线程并发 ：乐观锁 Synchronize关键字解决多线程并发”悲观锁“

##什么是乐观锁 悲观锁

##ois7层模型和tcp/ip四层模型？
##ois7层模型各层模型的主要协议、运行设备，端口号哪些？
##常用的网络通信协议 ： tcp  udp http ，ftp，pop3，smtp，  tcp udp编程 
##tcp和udp的区别 ？以及网络编程实现方式？

##socket了解 

##反射 
##如何获取一个类的描述类Class类的实例对象，三种方式

类名.class获取
实例变量名.getClass()
....
##什么是反射？ 反射的作用和意义？什么是CLass<T>

##使用java在内存中创建一个新对象的方式有哪几种？
1new 创建 
2对象流 创建 
3反射 创建 
4克隆创建 ；

##反射的编程 

##什么是注解？注解 和注释的区别？
注解 参与代码运行，给jvm血得，注释给人血得
##常用的元注解 ？各有什么作用 ？


##常见的排序算法以及稳定性？ 对应的时间复杂度与空间复杂度



