@20190826
##常用的集合类有哪些 ？具有哪些特性？是否有序，是否可以为null？是否排序？是否重复？
###实现list接口的类   有序、可重复
Linklist 实现List接口 ，允许null 。提供了额外的 get remove insert  LinkList没有同步方法，多线程访问时必须自己实现同步访问
ArrayList 实现可变大小的数组，允许所有元素 包括null ；没有同步 
Vector类似ArrayList，但是Vector是同步的。
Stack继承自vector，实现一个后进先出的堆栈。Stack提供五个额外的方法 push() 向尾端插入一个；pop 尾端删除 ；peek（）得到栈顶元素 
empty（）测试堆栈是否为空 search（）查找一个元素在堆栈中的位置。
    
###实现set接口的类 
无序、不能重复  最多只能有一个null
treeset ：二叉排序树 有序 

Map（键值对、键唯一、值不唯一）

数组 读写快 ；链表 增删快；哈希表 散列结构。
##collections array 工具类；
Collection 集合处理的工具类<br/>
排序  反转 随机排序 按自然顺序的升序排序，定制排序 交换索引位置的参数，
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。
当distance为负数时，将 list的前distance个元素整体移到后面。
查找binarySearch(List list, Object key) 二分查找返回索引，Max（）返回最大值的元素  替换 
同步控制 效率低 
Arrays类的常见操作<br/>
数组进行处理的工具类
排序 : sort() 
查找 : binarySearch() 
比较: equals() 
填充 : fill() 
转列表: asList() 
转字符串 : toString()  
##Comparator 和 Comparable 接口的作用和异同点？  <br/>
用来对自定义的class比较大小，<br/>
Comparable定义在类的内部，实现Comparable接口要覆盖compareTo方法, 在compareTo方法里面实现比较：<br/>

Comparator定义在person的外部，实现Comparator需要覆盖 compare 方法：<br/>

##泛型，什么是泛型，泛型的好处？
使用泛型时，类型转换由编译器完成，如果不使用泛型，类型转换由编程人员自己显式处理；<br/>
使用泛型，可以避免大量的方法的重载；<br/>
在编程时，如果指明了具体的泛型类型，则所用到的数据类型必须与泛型类型一致，即使可以进行类型自动转换也不允许；<br/>
在使用泛型时，指明的泛型的具体类型只能是引用类型，不能是基本类型，基本类型应该使用其对应的包装类类型；<br/>

泛型和方法重载有什么联系，泛型可以不可以使用基本类型，只能用包装类
是程序在编程时为了达到代码复用，在类、方法声明定义时，而使用泛型符号用于指代某种类型的一种编程方式；



##HashMap的底层实现的数据结构？  1.7- 数据+链表  1.8 数组+链表+红黑树 
HashMap采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改
可以接受null和键值; 基于hashing的原理，我们使用put（key，value）存储对象到hashMap中，
使用get（key）从Hashmap中获取对象。当我们给put方法传递键值时，先对键调用hashCode方法计算并
返回的hashCode是用于找到Map数组的bucket位置来储存Node对象。HashMap在bucjet中储存键对象和值对象，最为Map。Node


## 什么是红黑树 ？ 在hashMap中链表是如何转换为红黑树的，为什么使用红黑树。
自平衡二叉查找树 ，根节点是黑色的，叶子节点是黑色的空结点，红色节点的字节点是黑色的。
当链表长度超过8时，通过treeifyBin()方法转化成红黑树，
判断是否由根节点，然后选择插入左子树还是右子树 。

红黑树的插入删除和遍历的最坏时间复杂度都是log（n），当出现意外或恶意使用下导致hashCode（）方法返回值很差时，
性能下降少；

##HashMap的负载银子 是 0.75. Hash是如何扩容的？按照 16的整数倍递增。 Hash的初始长度为多少？ 16 
Map<String,object> map=new hashMap(30);

##什么叫对象流 是将内存中的某个时间节点的状体信息以字节流的形式，持久化到硬盘

什么是序列化 ？什么是反序列化？Serarizable接口的作用
把对象转换为字节序列的过程称为对象的序列化。
注意是对象
反序列化：把字节序列恢复为对象的过程称为对象的反序列化。

通过该接口启动序列化功能
未实现此接口的类将无法使其任何状态序列化或反序列化。
可序列化类的所有子类型本身都是可序列化的。因为实现接口也是间接的等同于继承。
序列化接口没有方法或字段，仅用于标识可序列化的语义。


##Transient关键字作用？修饰对象属性，不会被序列化，是否可以和final，static搭配使用？以及他们之间的区别 
用transient关键字标记的成员变量不参与序列化过程。
static 也无法被序列化 ，Transient修饰的变量在涉及序列化之外的地方就是正常的变量

##编程题 输入一个文件目录，将该文件目录中的文件内容汇总中含有java文件关键字的文件进行输出 递归 FileFilter接口


##扩展 NIO和NIO2的编程方式 
使用buffer channel
引入files ，paths两个工具类 
Filevisiter 遍历文件与目录 
watchservice 监控文件变化


##什么是进程？什么是线程 ？进程与线程之间的异同点？
程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
 线程是进程的执行的最小单位 单个进程中执行每个任务就是一个线程。
##线程的状态以及转换方式 ？
    就绪 运行 堵塞 
 挂起就绪 就绪 运行 堵塞（等待） 挂起等待    
新建 就绪 运行 堵塞  退出
##java多线程编程的实现方法？常用的线程操作的方法？
继承thread类
1定义一个类继承thread’
2重写run方法
3创建子类对象，创建线程对象，
4调用start对象，开启线程并让线程执行，同时让jvm去调用run方法。



声明实现该接口的类，实现重写run方法，创建Runnable的子类对象，传入某个线程的构造方法，开启线程

##多线程可以直接调用run方法，执行线程吗？
##线程类实现后，调用run方法和start方法有什么区别 ？  
直接创建，调用start，start调用的是run方法，run方法没有做事情，并且run方法中没有定义我们需要让线程执行的代码。
调用run方法只是调用了一个run方法，但是线程机制并没有启动。
##多线程常用的方法
start() 　使该线程开始执行；
run()　如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。
setName(String name)　改变线程名称，使之与参数 name 相同
setPriority(int piority)　更改线程的优先级。
isAlive()　测试线程是否处于活动状态。
yield()　暂停当前正在执行的线程对象，并执行其他线程。（主要作用就是让当前线程主动放弃 cpu 资源，让与其他线程执行）。  

线程死锁？线程死锁产生的条件 ？
互斥 请求与保持 循环等待 不可剥夺
如何避免线程产生死锁？Synchronize关键字的用法？
四个条件解除一条都可以避免；

锁类 或者锁对象
//第一种方式 锁定的是调用此方法的对象

public synchronized void Synchronized() {

    for (int i = 0; i < 200; i++) {

        synchronizedCount++;

    }

}

//第二种方式 synchronize锁static method 是以锁当前类的形式

public synchronized static void SynchronizedStaticMethod() {

    for (int i = 0; i < 200; i++) {

        synchronizedCount++;

    }

}

//第三种方式是在代码中锁定对象 锁的是调用此Synchronize方法中的的对象

public void SynchronizedObject(Object object) {

    synchronized (object) {

        for (int i = 0; i < 200; i++) {

            synchronizedCount++;

        }

    }

}

//第四种方式是在方法代码中锁定this 锁的是当前类对象  

//锁this详解 一个时间段只能有一个线程拿到锁 ，其他线程访问此方法的时候都必须得等待前面那个线程执行完

//即乌鸦在丢石头进瓶子的过程中，其他乌鸦可以去其他地方看有没有其他喝水的地方

//上面这个例子就是说明在访问synchronize锁定的方法时 可以去访问其他方法

public void SynchronizedThis() {

    synchronized (this) {

        for (int i = 0; i < 200; i++) {

            synchronizedCount++;

        }

    }

}



##什么是线程同步？
即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 
其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，

##线程的通信机制，
扩展 
##ConcurrentHashMap如何实现多线程并发的？ CAS无锁化解决多线程并发 ：乐观锁 Synchronize关键字解决多线程并发”悲观锁“

##什么是乐观锁 悲观锁
每次获取数据的时候，不担心数据被修改，但是每次更新时就担心是否被修改过，查询到被修改就不更新，没更改，就更新。数据没加锁，
被其他线程进行读写操作。
每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，
使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。在Java中，synchronized的思想也是悲观锁。
比较适合写入操作比较频繁的场景
##ois7层模型和tcp/ip四层模型？
应用 层                应用层
表述 
会话 

传输 

网络 					网络互联	

数据链路				数据链路 
物理 
##ois7层模型各层模型的主要协议、运行设备，端口号哪些？


##常用的网络通信协议 ： tcp  udp http ，ftp，pop3，smtp，  tcp udp编程 
##tcp和udp的区别 ？以及网络编程实现方式？
1：1.基于连接与无连接；
2.对系统资源的要求（TCP 较多，UDP 少）；
3.UDP 程序结构较简单；
4.流模式与数据报模式 ；
5.TCP 保证数据正确性，UDP 可能丢包，TCP 保证数据顺序，UDP 不保证。

1、创建一个 socket，用函数 socket()；
2、设置 socket 属性，用函数 setsockopt(); * 可选
3、绑定 IP 地址、端口等信息到 socket 上，用函数 bind();
4、开启监听，用函数 listen()；
5、接收客户端上来的连接，用函数 accept()；
6、收发数据，用函数 send()和 recv()，或者 read()和 write();
7、关闭网络连接；
8、关闭监听；
TCP 编程的客户端一般步骤是：
1、创建一个 socket，用函数 socket()；
2、设置 socket 属性，用函数 setsockopt();* 可选
3、绑定 IP 地址、端口等信息到 socket 上，用函数 bind();* 可选
4、设置要连接的对方的 IP 地址和端口等属性；
5、连接服务器，用函数 connect()；
6、收发数据，用函数 send()和 recv()，或者 read()和 write();
7、关闭网络连接；UDP:与之对应的 UDP 编程步骤要简单许多，分别如下：
UDP 编程的服务器端一般步骤是：
1、创建一个 socket，用函数 socket()；
2、设置 socket 属性，用函数 setsockopt();* 可选
3、绑定 IP 地址、端口等信息到 socket 上，用函数 bind();
4、循环接收数据，用函数 recvfrom();
5、关闭网络连接；
UDP 编程的客户端一般步骤是：
1、创建一个 socket，用函数 socket()；
2、设置 socket 属性，用函数 setsockopt();* 可选
3、绑定 IP 地址、端口等信息到 socket 上，用函数 bind();* 可选
4、设置对方的 IP 地址和端口等属性;
5、发送数据，用函数 sendto();
6、关闭网络连接；





##socket了解 


##如何获取一个类的描述类Class类的实例对象，三种方式
1:.class
2:.getClass()
3.Class.forName()

##什么是反射？ 反射的作用和意义？什么是CLass<T>

(1: JAVA 反射机制是在运行状态中，对于任意一个实体类，都能够获取这个类的所有
属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取类的
构造信息以及动态调用实例对象的行为方法的功能称为 java 语言的反射机制。
(2:java 的反射是动态的，在程序运行时才能获取的一些信息和操作；
java 的反射机制是对类在运行时的操作，是第三方（外部）的操作，不是类或者实
例对象本身的操作；
java 的反射机制是采用一种解剖的视角去分析和控制一个类或实例对象的行为动
作；不是这个类或实例本身的行为动作；
（3:Class 类：
Class 类是一个抽象封装类的类；
jvm 在反射机制中将一个类的构成信息进行抽象封装，使用 Class 类来进
行描述；
Class 是对某一个类的抽象封装，Class 是来自于一个具体的类在 jvm 执
行时所获取信息的抽象封装；
Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以
及通过调用类加载器中的 defineClass 方法自动构造的。

（4: 反射机制的使用，就是通过获取某一个类或实例对象的 Class 对象，进而通过
Class 对象进行操作处理；
反射就是操作一个类或实例对象的 Class；
注意带有 Declared 和不带有的 get 方法之间的区别：
不带有 Declared 的 get 方法只获取公共的内容；
带有 Declared 的 get 方法获取所有的内容，包括 public、protected、默认
的、private；




##使用java在内存中创建一个新对象的方式有哪几种？
1new 创建 
2对象流 创建 
3反射 创建 
4克隆创建 ；

##反射的编程 

##什么是注解？注解 和注释的区别？
注解 参与代码运行，给jvm血得，注释给人血得
##常用的元注解 ？各有什么作用 ？

1：注解是 java 程序中使用元数据对功能代码进行补充说明的一种编程方式；
注解是在 jdk1.5 以后才支持的；
注解使用使用在类、属性、方法、构造方法、局部变量、参数、枚举类型上，之
前用的注解有 @override @Test
（2：注解与注释的区别：
注释：
是对程序的解释说明的内容，是给编程人员阅读理解代码使用；
注释不参与程序的编译运行；
注解：
是对程序的补充说明，是给 jvm 在编译运行程序时使用的“注释说
明”
注解是参与程序的编译运行的；
★
注释是给编程人员看的，不参与程序的编译运行；
注解是给 jvm 看的，参与程序的编译运行；
★
（3：@Target
用于指定注解所可以修饰的范围
范围从枚举类 ElementType 中获取
如果不写，默认应用范围是所有的可以使用注解的范围；
不写默认是应用于全部；
@Retention
用于指定自定义注解的生命周期长度；
通过 RetentionPolicy 类中的静态变量指定：
RetentionPolicy.SOURCE
源码级，jvm 编译时会直接丢弃，不参与编译；
RetentionPolicy.CLASS 默认值
编译级，注解存活到编译期间，运行期间在被 jvm 丢弃；
RetentionPolicy.RUNTIME
运行级，注解存活到运行时，从源码、编译、运行注解都
存活；
默认值是 Class 源码级别
@Documented
决定在使用 javadoc 自动生成的 api 文档中包不包含该注解信息；
默认不包含；使用该注解表示 api 中包含该注解的内容；
@Inherited
决定父类的注解可不可以被子类继承到；
默认是不继承；使用该注解表示子类可以继承；

##常见的排序算法以及稳定性？ 对应的时间复杂度与空间复杂度



